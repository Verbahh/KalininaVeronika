# Инструкция по работе с git

## Seminar 1
## Команды GIT
**Программа GIT** осуществляет контроль версий и позволяет переключаться между ними.

**Команды GIT:**

* *git version* - показывает текущую версию git, установленную на компьютер.

* *git init* - команда, позволяющая сделать из нашей папки репозиторий.

> *Репозиторий* - это папка, в которой настроена система контроля версий. Это команду надо сделать в той папке, из которой хотим сделать репозиторий.

* *git status* - показывает текущее состояние git, есть ли изменения, которые нужно закоммитить.

* *git add* - команда, которая добавляет содержимое рабочего фйла в индекс для последующего коммита.

* *git commits* - команда, позволяющая фиксировать текущее состояние наших файлов. Оставляем обязательно текстовый комментарий (напоминание), что конкретно сделали.

> *Commits* - фиксация.

> Команда *git commit* берет все данные, добавленные в индекс с помощью *git add*, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущий ветки на этот слепок.

* *git log* - позволяет посмотреть журнал всех изменений.

* *git checkout* - позволяет переключаться между версиями. В конце команды добавляем первые символы номера интересующего коммита.

* *git diff* - показывает отличие нашего текущего файла с тем, что уже закоммичино.


> *Difference* - отличие, разница.

О других командах Git можно узнать [здесь](https://habr.com/ru/company/ruvds/blog/599929/).

## Seminar 2
## Работа с ветками

### 1. Создание веток

* *git branch* - с помощью этой команды можно посмотреть, сколько ветвей в репозитории и на какой ветки на данный момент находимся (отмечено *).
> *Branch* - ветвь, ветвление.
* *git branch new_branch_name* - команда, позволяющая создать новую ветку.
* *git checkout new_branch_name* - команда, позволяющая перейти на вновь созданную ветку.

Команда *git log* показывать журнал всех изменений. Но если вызывать эту команду из самой свежей ветки, мы не увидим исходного файла, то есть *git log* будет показывать изменения только по той ветке, в которой находимся.

### 2. Слияние веток

* *git merge existing_branch_name* - команда, позволяющая сливать (объединять) ветки. Вызываем этой команду в той ветке, в которую хотим перенести данные.

При слиянии веток может быть несколько вариантов итогов. Например:
1. слияние, при котором обновляется базовая ветка, и нет объединения разной информации из двух веток.
2. слияние, при котором в двух ветках есть уникальные коммиты, содержимое которых никак не связано друг с другом и не противеречат друг другу(такой вариант возможен, если рассматривать позиции этих коммитов, находящиеся на разных строках).
3. слияние, при котором возникает конфликт, то есть строки одинаковые, а содержание этих строк разное.

### 3. Конфликты при слиянии

Когда возникает конфликт при слиянии веток, мы должны решить данные противоречия и закоммитить результат.

Существует несколько вариантой действий при возникновении конфликта: 
* **Accept Current Change** - оставить только те изменения, которые находятся в текущей ветке.
* **Accept Incoming Change** - оставить только те изменения, которые пришли из входящей ветки.
* **Accept Both Changes** - оставить оба варианта.
* **Compare Changes** - открыть редактор и исправить конфликт в нем теми же способами.

> *git merge --abort* - при конфликет можно прервать слияние параметром *merge* с флагом *--abort*. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

>*git reset* - при конфликте слияния можно использовать *reset*, чтобы восстановить конфликтующие файлы до стабильного состояния.

### 4. Удаление веток

* *branch -d existing_branch_name* - удаление ветки.
Если завершена работа над веткой, и она объединена с основной, ее можно удалить без потери истории. Если выполнить удаление до слияния - в результате появится сообщение об ошибке. Этот щадитный механизм предотвращает потерю доступа к файлам.

* *git branch -D existing_branch_name* - принудительное удаление ветки. При использовании флага *-D* с заглавной буквой ветка будет удалена независимо от текущего статуса, без предупреждения.

* *git push origin --delete existing_branch_name* - стереть удаленную ветку. Две команды выше удаляют только локальную копию ветки, в удаленном репозитории она может сохраниться.

## Seminar 3
## Работа с GitHub

**Команды GIT:**

* *git clone* - позволяет скопировать внешний репозиторий на свой локальный.

Команда git clone составная: она не только загружает все изменения, но и пытается слить все ветки на локальном компьютере и в удаленном репозитории.

* *git pull* - команда позволяет скачать все из текущего репозитория и автоматически сделать merge с нашей версией.

* *git push* - команда, позволяющая отправить лоакальную версию репозитория во внешний репозиторий. Команда требует авторизации на внешнем репозитории. 

Если делать изменения в GitHub, автоматически они не будут появляться в локальном репозитории.

**Настраиваем совместную работу:**

1. Создать аккаунт на GitHub.
2. Создать локальный репозиторий.
3. “Подружить” ваш локальный и удаленный репозиторий.
4. Отправить (push) ваш локальный репозиторий в удаленный на GitHub, при этом, возможно, вам нужно будет авторизоваться на удаленном репозитории.
5. Провести изменения “с другого компьютера”.
6. Выкачать (pull) актуальное состояние из удаленного репозитория.

В больших компаниях один ответственный за проект создает аккаунт. Другие пользователи дают команду pull request. Предлагать изменения на GitHub нужно в отдельной ветке. Сначала пользователь копирует репозиторий на свой компьютер, делает fork репозитория, затем клонирует версию на своём ПК, создаёт ветку с предлагаемыми изменениями, отправляет изменения командой push в свой аккаунт на GitHub и даёт команду pull request.

1. Делаем ответвление (fork) репозитория.
2. Делаем git clone для нашей версии этого репозитория.
3. Создаем ветку с предлагаемыми изменениями.
4. Производим все изменения только в этой ветке.
5. Отправляем эти изменения на свой аккаунт (push).
6. В окне на GitHub появляется возможность отправить pull request с нашими изменениями.
